# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Release automation script."""

from __future__ import annotations

import argparse
import logging
import os
import re
import subprocess
from datetime import datetime
from pathlib import Path

import github
import github.GitRelease
import github.Repository

formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('release')
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger.addHandler(handler)


if 'GITHUB_TOKEN' not in os.environ:
    raise SystemExit('Environment variable GITHUB_TOKEN not set.')

auth = github.Auth.Token(os.environ['GITHUB_TOKEN'])
gh_client = github.Github(auth=auth)


VERSION_REGEX = r'(\d+\.\d+\.\d+(?:\.dev\d+)?)'
VERSION_FILES = {
    'ops/src': Path('ops/version.py'),
    'ops/pyproject': Path('pyproject.toml'),
    'testing': Path('testing/pyproject.toml'),
    'tracing': Path('tracing/pyproject.toml'),
    'uvlock': Path('uv.lock'),
}


def get_latest_release_tag(repo: github.Repository.Repository, branch_name: str) -> str | None:
    """Get the latest release tag from the repository."""
    releases = repo.get_releases()

    for release in releases:
        if release.draft:
            continue

        if 'maintenance' in branch_name:
            version = branch_name.split('-')[0]
            if version not in release.tag_name:
                continue

        return release.tag_name

    return None


def bump_minor_version(version: str) -> str:
    """Bump minor version."""
    major, minor, patch = map(int, version.split('.'))
    return f'{major}.{minor + 1}.{patch}'


def get_new_tag_for_release(
    owner: str, repo: github.Repository.Repository, branch_name: str
) -> str:
    """Get a new tag for release.

    Default value is generated by increasing the minor version of the latest release's tag.

    Can be overridden with a user-provided version.
    """
    latest_tag = get_latest_release_tag(repo, branch_name)

    suggested_tag = ''
    if not latest_tag:
        logger.info(f'No version tag found in branch "{branch_name}"')
    else:
        logger.info(f'Latest tag in branch "{branch_name}": {latest_tag}')
        if not re.match(r'^\d+\.\d+\.\d+$', latest_tag):
            logger.info('Latest tag is not in format X.Y.Z.')
        else:
            suggested_tag = bump_minor_version(latest_tag)
            logger.info(f'Suggested new version: {suggested_tag}')

    tag_prompt = f' (press enter to use the tag {suggested_tag})' if suggested_tag else ''
    prompt = f"Input the new tag for the release{tag_prompt}, or 'c' to cancel:\n"
    while True:
        user_input = input(prompt).strip()
        if user_input.lower() == 'c':
            logger.warning('Release canceled.')
            exit(0)

        new_tag = user_input if user_input else suggested_tag

        if not new_tag:
            logger.error('Error: No tag specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', new_tag):
            logger.error('Error: Tag must be in format X.Y.Z')
            continue

        release_page = f'https://github.com/{owner}/{repo.name}/releases'
        logger.warning(f'Check out the releases page: {release_page} before confirming!')

        confirm = (
            input(f"Confirm creating tag '{new_tag}' on branch '{branch_name}'? [y/N]: ")
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return new_tag


def create_draft_release(
    repo: github.Repository.Repository, tag: str, branch: str
) -> github.GitRelease.GitRelease | None:
    """Create a draft release with auto-generated notes."""
    try:
        release = repo.create_git_release(
            tag=tag,
            name=tag,
            draft=True,
            generate_release_notes=True,
            target_commitish=branch,
        )
        return release
    except Exception as e:
        logger.error(f'Failed to create release: {e}')
        return None


def parse_release_notes(release_notes: str) -> tuple[dict[str, list[tuple[str, str]]], str | None]:
    """Parse auto-generated release notes into categories.

    The "New Contributors" section is removed.
    The PRs are categorized into 'feat', 'fix', 'docs', 'test', and 'ci'.
    The full changelog line is returned separately.

    Returns:
        A tuple containing:
        - A dict with conventional commit types as keys and lists of tuples (description, PR link)
          as values.
        - The full changelog line if present, or None if not found.
    """
    release_notes = re.sub(
        r'(## New Contributors.*?)(\n|$)', r'\2', release_notes, flags=re.DOTALL
    )
    categories: dict[str, list[tuple[str, str]]] = {
        'feat': [],
        'fix': [],
        'docs': [],
        'test': [],
        'ci': [],
    }
    full_changelog_line = None

    for line in release_notes.splitlines():
        if match := re.match(r'^\* (\w+): (.*) by @\w+ in (.*)', line.strip()):
            category = match.group(1)
            if category in categories:
                description = match.group(2).strip().capitalize()
                pr_link = match.group(3).strip()
                categories[category].append((description, pr_link))
        elif line.startswith('**Full Changelog**'):
            full_changelog_line = line

    return categories, full_changelog_line


def format_release_notes(
    categories: dict[str, list[tuple[str, str]]], full_changelog: str | None
) -> str:
    """Format for release notes.

    Results in a Markdown formatted string with sections for each commit type.
    If `full_changelog` is provided, it is appended at the end.
    """
    lines = ["## What's Changed", '', '']  # Initialize lines.
    for commit_type, items in categories.items():
        if items:
            lines.append(f'### {commit_type_to_category(commit_type)}')  # Add category header.
            for description, pr_link in items:
                lines.append(f'* {description} in {pr_link}')  # Add commit description.
            lines.append('')  # Add a blank line after each category.
    if full_changelog:
        lines.append(full_changelog)  # Append the full changelog.
    return '\n'.join(lines)  # Join the lines with newline characters.


def print_release_notes(notes: str):
    """Print formatted release notes.

    So that user can review them and use them to write the title and summary.
    """
    print('=' * 80)
    print('Formatted release notes:')
    print('=' * 80)
    print(notes)
    print('=' * 80)


def input_title_and_summary(release: github.GitRelease.GitRelease) -> tuple[str, str]:
    """Ask user to input the release title and summary."""
    logger.info(f'The automatically generated title is: {release.title}')
    title = input('Enter release title, press Enter to keep the auto-generated title:\n> ').strip()
    if not title:
        title = release.title

    print("\nEnter release summary (multi-line supported; type '.' on a new line to finish):")

    lines: list[str] = []
    while True:
        line = input()
        if line.strip() == '.':
            break
        lines.append(line)

    summary = '\n'.join(lines).strip()
    summary = summary.lstrip('\n')
    summary = summary.rstrip('\n') + '\n'

    return title, summary


def update_draft_release(release: github.GitRelease.GitRelease, title: str, notes: str):
    """Update the release with the provided title and notes."""
    try:
        release.update_release(name=title, message=notes, draft=True)
        logger.info('Release title and notes updated.')
    except Exception as e:
        logger.error(f'Failed to update release: {e}')


def format_changes(categories: dict[str, list[tuple[str, str]]], tag: str) -> str:
    """Format for CHANGES.md.

    The header is formatted as a top-level heading with the tag and date.
    The content is a Markdown formatted string with sections for each commit type.
    Each item is formatted as a bullet point with the description and PR number in parentheses.
    """
    today = datetime.now().strftime('%d %B %Y')
    res = f'# {tag} - {today}\n\n'

    for commit_type, items in categories.items():
        if items:
            res += f'## {commit_type_to_category(commit_type)}\n\n'

            for description, pr_link in items:
                pr_num = '?'
                match = re.match(r'https?://[^ ]+/pull/(\d+)', pr_link)
                if match:
                    pr_num = match.group(1)
                res += f'* {description} (#{pr_num})\n'

            res += '\n'

    return res


def update_changes_file(changes: str, file: str):
    """Update the changes file with new release notes."""
    file_path = Path(file)
    existing_content = file_path.read_text() if file_path.exists() else ''
    file_path.write_text(changes + existing_content)
    logger.info(f'Updated {file} with new release notes.')


def commit_type_to_category(commit_type: str) -> str:
    """Map commit type to a human-readable category.

    If the commit type is not recognized, it returns the capitalized commit type.
    """
    mapping = {
        'feat': 'Features',
        'fix': 'Fixes',
        'docs': 'Documentation',
        'test': 'Tests',
        'ci': 'CI',
    }
    return mapping.get(commit_type, commit_type.capitalize())


def parse_version(version: str) -> tuple[str, str]:
    """Parse version string into base version and dev suffix.

    The version should be in the format X.Y.Z or X.Y.Z.devN.
    The ".devN" part is the dev suffix.
    If there is no dev suffix, it returns an empty string for the dev suffix.

    Raises:
        ValueError if the version format is invalid.
    """
    match = re.fullmatch(r'(\d+\.\d+\.\d+)(\.dev\d+)?', version)
    if not match:
        raise ValueError(f'Invalid version format: {version}')
    base_version = match.group(1)
    dev_suffix = match.group(2) or ''
    return base_version, dev_suffix


def update_pyproject_versions(path: Path, version: str, deps: dict[str, str]) -> None:
    """Update versions in pyproject.toml."""
    content = path.read_text()
    updated = re.sub(rf'version = "{VERSION_REGEX}"', f'version = "{version}"', content)
    for pkg, pkg_version in deps.items():
        updated = re.sub(rf'{pkg}=={VERSION_REGEX}', f'{pkg}=={pkg_version}', updated)
    if content == updated:
        logger.error(f'No changes made to {path}. Check the versions.')
        exit(1)
    path.write_text(updated)
    logger.info(f'Updated {path} to version {version}')


def update_ops_version(ops_version: str, testing_version: str):
    """Update the ops version in version.py and pyproject.toml."""
    # version.py
    ops_src_file_path = VERSION_FILES['ops/src']
    content = ops_src_file_path.read_text()
    updated = re.sub(
        rf"^version: str = '{VERSION_REGEX}'$",
        f"version: str = '{ops_version}'",
        content,
        flags=re.MULTILINE,
    )
    ops_src_file_path.write_text(updated)
    logger.info(f'Updated {ops_src_file_path} to version {ops_version}')

    # pyproject.toml, update both ops-scenario and ops-tracing versions.
    update_pyproject_versions(
        VERSION_FILES['ops/pyproject'],
        testing_version,
        deps={'ops-scenario': testing_version, 'ops-tracing': ops_version},
    )


def update_testing_version(ops_version: str, testing_version: str):
    """Update the testing pyproject version."""
    update_pyproject_versions(VERSION_FILES['testing'], testing_version, deps={'ops': ops_version})


def update_tracing_version(ops_version: str):
    """Update the tracing pyproject version."""
    update_pyproject_versions(VERSION_FILES['tracing'], ops_version, deps={'ops': ops_version})


def update_uv_lock():
    """Update the uv.lock file with the new versions."""
    subprocess.run(['uv', 'lock'], check=True)  # noqa: S607


def parse_scenario_version():
    """Parse the current scenario version from pyproject.toml."""
    file_path = VERSION_FILES['testing']
    content = file_path.read_text()
    match = re.search(rf'version = "{VERSION_REGEX}"', content)
    if not match:
        raise ValueError(f'Could not find version string in {file_path}')
    version_str = match.group(1)
    base_version, dev_suffix = parse_version(version_str)
    return base_version, dev_suffix


def get_new_scenario_version_for_release() -> str:
    """Get a new version for scenario.

    Default value is generated by removing the ".dev0" suffix from the current scenario version.

    Can be overridden with a user-provided version.
    """
    suggested_version, _ = parse_scenario_version()
    logger.info(f'Suggested new scenario version: {suggested_version}')

    while True:
        user_input = input(
            f'Input new scenario version (press enter to use the suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Scenario version creation canceled.')
            exit(0)

        suggested_version = user_input if user_input else suggested_version

        if not suggested_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', suggested_version):
            logger.error('Error: Version must be in format X.Y.Z')
            continue

        confirm = (
            input(f"Confirm using scenario version '{suggested_version}'? [y/N]: ").strip().lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return suggested_version


def update_versions_for_release(tag: str):
    """Update version files to the specified release version."""
    scenario_version = get_new_scenario_version_for_release()
    update_ops_version(tag, scenario_version)
    update_testing_version(tag, scenario_version)
    update_tracing_version(tag)
    update_uv_lock()


def get_new_version_post_release(repo: github.Repository.Repository, branch_name: str) -> str:
    """Get the new version after the release.

    Default value is generated by bumping the minor version of the latest release's tag
    and adding the '.dev0' suffix.

    Can be overridden with a user-provided version.
    """
    latest_version = get_latest_release_tag(repo, branch_name)

    if latest_version is None:
        logger.info('No version tags found in branch "{branch_name}".')
        suggested_version = ''
    else:
        logger.info(f'Latest version in branch "{branch_name}": {latest_version}')

        # Check if the latest version is in SEMVER, in case it has a suffix.
        if not re.match(r'^\d+\.\d+\.\d+$', latest_version):
            logger.warning(
                f'Latest version "{latest_version}" must be in format '
                f'X.Y.Z. Please input the new version manually (remember to add the .dev0 suffix).'
            )
            suggested_version = ''
        else:
            suggested_version = bump_minor_version(latest_version) + '.dev0'
            logger.info(f'Suggested new version: {suggested_version}')

    while True:
        user_input = input(
            f'Input post release version (press enter to use suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Post release canceled.')
            exit(0)

        new_version = user_input if user_input else suggested_version

        if not new_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        confirm = (
            input(f"Confirm using version '{new_version}' for post release'? [y/N]: ")
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return new_version


def get_new_scenario_version_post_release() -> str:
    """Get a new post release version for scenario.

    Default value is generated by bumping the current minor version and add the .dev0 suffix.

    Can be overridden with a user-provided version.
    """
    current_version, _ = parse_scenario_version()
    suggested_version = bump_minor_version(current_version) + '.dev0'
    logger.info(f'Suggested new scenario version: {suggested_version}')

    while True:
        user_input = input(
            f'Input post release scenario version (press enter to use suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Post release canceled.')
            exit(0)

        suggested_version = user_input if user_input else suggested_version

        if not suggested_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+\.dev\d+$', suggested_version):
            logger.error('Error: Version must be in format X.Y.Z.devN')
            continue

        confirm = (
            input(
                f"Confirm using scenario version '{suggested_version}' for post release? [y/N]: "
            )
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return suggested_version


def update_versions_for_post_release(repo: github.Repository.Repository, branch_name: str):
    """Update version files to the post-release version with '.dev0' suffix."""
    ops_version = get_new_version_post_release(repo, branch_name)
    scenario_version = get_new_scenario_version_post_release()
    update_ops_version(ops_version, scenario_version)
    update_testing_version(ops_version, scenario_version)
    update_tracing_version(ops_version)
    update_uv_lock()


def check_update_charm_pins_prs(repo: github.Repository.Repository):
    """Check for open PRs that update charm pins."""
    prs = repo.get_pulls(state='open')
    open_prs = [pr for pr in prs if pr.title == 'chore: update charm pins']
    if open_prs:
        logger.info('Please merge "update charm pins" PRs first:')
        pr = open_prs[0]
        pr_url = f'#{pr.number} - {pr.html_url}'
        logger.info(f'  {pr_url}')
        if len(open_prs) > 1:
            logger.info(
                f'Note that there are {len(open_prs) - 1} more open update charm pins PRs.'
            )


def draft_release(owner: str, repo_name: str, base_branch: str):
    """Create a draft release, update changelog, and create a PR for the release."""
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    check_update_charm_pins_prs(repo)

    tag = get_new_tag_for_release(owner, repo, base_branch)
    release = create_draft_release(repo, tag, base_branch)
    if not release:
        logger.error('Failed to create draft release.')
        exit(1)
    logger.info(f'Draft release created: {release.html_url}.')

    categories, full_changelog = parse_release_notes(release.body)
    notes = format_release_notes(categories, full_changelog)
    print_release_notes(notes)

    title, summary = input_title_and_summary(release)
    if not title:
        title = tag
    notes = f'{summary}\n{notes}'

    update_draft_release(release, title, notes)

    changes = format_changes(categories, tag)
    update_changes_file(changes, 'CHANGES.md')

    update_versions_for_release(tag)

    new_branch = f'release-prep-{tag}'
    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    changed_files = ['CHANGES.md', *[str(path) for path in VERSION_FILES.values()]]
    for file in changed_files:
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(['/usr/bin/git', 'commit', '-m', f'chore: prepare release {tag}'], check=True)
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title=f'chore: update changelog and versions for {tag} release',
        body=f'This PR prepares the release of version {tag}.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=base_branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


def post_release(owner: str, repo_name: str, base_branch: str):
    """Post-release actions: update version files and create a PR."""
    new_branch = 'post-release'
    local_branch = subprocess.run(
        ['/usr/bin/git', 'branch', '--list', new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    remote_branch = subprocess.run(
        ['/usr/bin/git', 'ls-remote', '--heads', 'origin', new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    exist = local_branch or remote_branch
    if exist:
        logger.error(
            f'Branch "{new_branch}" already exists in the current repository. '
            'Please double check and delete it first before post release'
        )
        exit(1)

    subprocess.run(['/usr/bin/git', 'fetch', 'upstream'], check=True)
    subprocess.run(['/usr/bin/git', 'checkout', base_branch], check=True)
    subprocess.run(['/usr/bin/git', 'merge', f'upstream/{base_branch}'], check=True)

    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    update_versions_for_post_release(repo, base_branch)

    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    for file in [str(path) for path in VERSION_FILES.values()]:
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(
        ['/usr/bin/git', 'commit', '-m', 'chore: update versions after release'], check=True
    )
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title='chore: adjust versions after release',
        body='This PR updates the version files after the release.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=base_branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--repo',
        '-r',
        help='Repository name (e.g. "operator")',
        default='operator',
    )
    parser.add_argument(
        '--owner',
        '-o',
        help='Owner name (e.g. "canonical")',
        default='canonical',
    )
    parser.add_argument('--branch', '-b', help='Branch to create the release from', default='main')
    parser.add_argument(
        '--post-release',
        action='store_true',
        help='After release, bump version and add .dev0 suffix',
    )
    args = parser.parse_args()

    if args.post_release:
        post_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
        logger.info(
            'Post-release actions completed. Please check and merge the created PR '
            'for version updates.'
        )
        exit(0)

    draft_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
    logger.info(
        'Draft release created. Please merge the version bump PR, publish the draft release, then'
        'run this script with --post-release to perform post-release actions.'
    )
