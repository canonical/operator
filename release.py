# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Release automation script."""

from __future__ import annotations

import argparse
import datetime
import logging
import os
import pathlib
import re
import subprocess

import github
import github.GitRelease
import github.Repository

formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger('release')
logger.setLevel(logging.INFO)
handler = logging.StreamHandler()
handler.setFormatter(formatter)
logger.addHandler(handler)


if 'GITHUB_TOKEN' not in os.environ:
    raise SystemExit('Environment variable GITHUB_TOKEN not set.')

auth = github.Auth.Token(os.environ['GITHUB_TOKEN'])
gh_client = github.Github(auth=auth)


VERSION_REGEX = r'(\d+\.\d+\.\d+(?:\.dev\d+)?)'
VERSION_FILES = {
    'ops/src': pathlib.Path('ops/version.py'),
    'ops/pyproject': pathlib.Path('pyproject.toml'),
    'testing': pathlib.Path('testing/pyproject.toml'),
    'tracing': pathlib.Path('tracing/pyproject.toml'),
    'uvlock': pathlib.Path('uv.lock'),
}


def get_latest_release_tag(repo: github.Repository.Repository, branch_name: str) -> str | None:
    """Get the latest release tag from the repository."""
    releases = repo.get_releases()

    maintenance_branch_version = (
        branch_name.removesuffix('-maintenance') if branch_name.endswith('-maintenance') else None
    )

    for release in releases:
        if release.draft:
            continue

        if maintenance_branch_version and maintenance_branch_version not in release.tag_name:
            continue

        return release.tag_name

    return None


def bump_minor_version(version: str) -> str:
    """Bump minor version."""
    major, minor, _ = map(int, version.split('.'))
    return f'{major}.{minor + 1}.0'


def get_new_tag_for_release(
    owner: str, repo: github.Repository.Repository, branch_name: str
) -> str:
    """Get a new tag for release.

    Default value is generated by increasing the minor version of the latest release's tag.

    Can be overridden with a user-provided version.
    """
    latest_tag = get_latest_release_tag(repo, branch_name)

    suggested_tag = ''
    if not latest_tag:
        logger.info(f'No version tag found in branch "{branch_name}"')
    else:
        logger.info(f'Latest tag in branch "{branch_name}": {latest_tag}')
        if not re.match(r'^\d+\.\d+\.\d+$', latest_tag):
            logger.info('Latest tag is not in format X.Y.Z.')
        else:
            suggested_tag = bump_minor_version(latest_tag)
            logger.info(f'Suggested new version: {suggested_tag}')

    tag_prompt = f' (press enter to use the tag {suggested_tag})' if suggested_tag else ''
    prompt = f'Input the new tag for the release{tag_prompt}\n'
    while True:
        user_input = input(prompt).strip()

        new_tag = user_input or suggested_tag

        if not new_tag:
            logger.error('Error: No tag specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', new_tag):
            logger.error('Error: Tag must be in format X.Y.Z')
            continue

        release_page = f'https://github.com/{owner}/{repo.name}/releases'
        logger.warning(f'Check out the releases page: {release_page} before confirming!')

        confirm = (
            input(f'Confirm creating tag {new_tag!r} on branch {branch_name!r}? [y/N]: ')
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return new_tag


def create_draft_release(
    repo: github.Repository.Repository, tag: str, branch: str
) -> github.GitRelease.GitRelease | None:
    """Create a draft release with auto-generated notes."""
    release = repo.create_git_release(
        tag=tag,
        name=tag,
        draft=True,
        generate_release_notes=True,
        target_commitish=branch,
    )
    return release


def parse_release_notes(release_notes: str) -> tuple[dict[str, list[tuple[str, str]]], str | None]:
    """Parse auto-generated release notes into categories.

    The "New Contributors" section is removed.
    The PRs are categorized into 'feat', 'fix', 'docs', 'test', and 'ci'.
    The full changelog line is returned separately.

    Returns:
        A tuple containing:
        - A dict with conventional commit types as keys and lists of tuples (description, PR link)
          as values.
        - The full changelog line if present, or None if not found.
    """
    release_notes = re.sub(
        r'(## New Contributors.*?)(\n|$)', r'\2', release_notes, flags=re.DOTALL
    )
    categories: dict[str, list[tuple[str, str]]] = {
        'feat': [],
        'fix': [],
        'docs': [],
        'test': [],
        'ci': [],
    }
    full_changelog_line = None

    for line in release_notes.splitlines():
        if match := re.match(r'^\* (\w+): (.*) by @\w+ in (.*)', line.strip()):
            category = match.group(1)
            if category in categories:
                description = match.group(2).strip().capitalize()
                pr_link = match.group(3).strip()
                categories[category].append((description, pr_link))
            else:
                logger.warning(
                    f'Unexpected category {category} found in the auto-generated release notes'
                )

        elif line.startswith('**Full Changelog**'):
            full_changelog_line = line

    return categories, full_changelog_line


def format_release_notes(
    categories: dict[str, list[tuple[str, str]]], full_changelog: str | None
) -> str:
    """Format for release notes.

    Results in a Markdown formatted string with sections for each commit type.
    If `full_changelog` is provided, it is appended at the end.
    """
    lines = ["## What's Changed", '', '']  # Initialize lines.
    for commit_type, items in categories.items():
        if items:
            lines.append(f'### {commit_type_to_category(commit_type)}')  # Add category header.
            for description, pr_link in items:
                lines.append(f'* {description} in {pr_link}')  # Add commit description.
            lines.append('')  # Add a blank line after each category.
    if full_changelog:
        lines.append(full_changelog)  # Append the full changelog.
    return '\n'.join(lines)  # Join the lines with newline characters.


def print_release_notes(notes: str):
    """Print formatted release notes.

    So that user can review them and use them to write the title and summary.
    """
    print('=' * 80)
    print('Formatted release notes:')
    print('=' * 80)
    print(notes)
    print('=' * 80)


def input_title_and_summary(release: github.GitRelease.GitRelease) -> tuple[str, str]:
    """Ask user to input the release title and summary."""
    logger.info(f'The automatically generated title is: {release.title}')
    title = input('Enter release title, press Enter to keep the auto-generated title:\n> ').strip()
    if not title:
        title = release.title

    print("\nEnter release summary (multi-line supported; type '.' on a new line to finish):")

    lines: list[str] = []
    while True:
        line = input()
        if line.strip() == '.':
            break
        lines.append(line)

    summary = '\n'.join(lines).strip() + '\n'

    return title, summary


def update_draft_release(release: github.GitRelease.GitRelease, title: str, notes: str):
    """Update the release with the provided title and notes."""
    release = release.update_release(name=title, message=notes, draft=True)
    logger.info(f'Release updated: {release.html_url}.')


def format_changes(categories: dict[str, list[tuple[str, str]]], tag: str) -> str:
    """Format for CHANGES.md.

    The header is formatted as a top-level heading with the tag and date.
    The content is a Markdown formatted string with sections for each commit type.
    Each item is formatted as a bullet point with the description and PR number in parentheses.
    """
    today = datetime.datetime.now().strftime('%d %B %Y')
    lines = [f'# {tag} - {today}\n']  # Initialize lines with the header.

    for commit_type, items in categories.items():
        if items:
            lines.append(f'## {commit_type_to_category(commit_type)}\n')
            for description, pr_link in items:
                pr_num = '?'
                match = re.match(r'https?://[^ ]+/pull/(\d+)', pr_link)
                if match:
                    pr_num = match.group(1)
                lines.append(f'* {description} (#{pr_num})')
            lines.append('\n')  # Add a blank line after each category.

    return '\n'.join(lines)  # Join the lines with newline characters.


def update_changes_file(changes: str, file: str):
    """Update the changes file with new release notes."""
    file_path = pathlib.Path(file)
    existing_content = file_path.read_text() if file_path.exists() else ''
    file_path.write_text(changes + existing_content)
    logger.info(f'Updated {file} with new release notes.')


def commit_type_to_category(commit_type: str) -> str:
    """Map commit type to a human-readable category.

    If the commit type is not recognized, it returns the capitalized commit type.
    """
    mapping = {
        'feat': 'Features',
        'fix': 'Fixes',
        'docs': 'Documentation',
        'test': 'Tests',
        'ci': 'CI',
    }
    return mapping.get(commit_type, commit_type.capitalize())


def parse_version(version: str) -> tuple[str, str]:
    """Parse version string into base version and dev suffix.

    The version should be in the format X.Y.Z or X.Y.Z.devN.
    The ".devN" part is the dev suffix.
    If there is no dev suffix, it returns an empty string for the dev suffix.

    Raises:
        ValueError if the version format is invalid.
    """
    match = re.fullmatch(r'(\d+\.\d+\.\d+)(\.dev\d+)?', version)
    if not match:
        raise ValueError(f'Invalid version format: {version}')
    base_version = match.group(1)
    dev_suffix = match.group(2) or ''
    return base_version, dev_suffix


def update_pyproject_versions(path: pathlib.Path, version: str, deps: dict[str, str]) -> None:
    """Update versions in pyproject.toml."""
    content = path.read_text()
    updated = re.sub(rf'version = "{VERSION_REGEX}"', f'version = "{version}"', content)
    for pkg, pkg_version in deps.items():
        updated = re.sub(rf'{pkg}=={VERSION_REGEX}', f'{pkg}=={pkg_version}', updated)
    if content == updated:
        logger.error(f'No changes made to {path}. Check the versions.')
        exit(1)
    path.write_text(updated)
    logger.info(f'Updated {path} to version {version}')


def update_ops_version(ops_version: str, testing_version: str):
    """Update the ops version in version.py and pyproject.toml."""
    # version.py
    ops_src_file_path = VERSION_FILES['ops/src']
    content = ops_src_file_path.read_text()
    updated = re.sub(
        rf"^version: str = '{VERSION_REGEX}'$",
        f"version: str = '{ops_version}'",
        content,
        flags=re.MULTILINE,
    )
    ops_src_file_path.write_text(updated)
    logger.info(f'Updated {ops_src_file_path} to version {ops_version}')

    # pyproject.toml, update both ops-scenario and ops-tracing versions.
    update_pyproject_versions(
        VERSION_FILES['ops/pyproject'],
        testing_version,
        deps={'ops-scenario': testing_version, 'ops-tracing': ops_version},
    )


def update_testing_version(ops_version: str, testing_version: str):
    """Update the testing pyproject version."""
    update_pyproject_versions(VERSION_FILES['testing'], testing_version, deps={'ops': ops_version})


def update_tracing_version(ops_version: str):
    """Update the tracing pyproject version."""
    update_pyproject_versions(VERSION_FILES['tracing'], ops_version, deps={'ops': ops_version})


def update_uv_lock():
    """Update the uv.lock file with the new versions."""
    subprocess.run(['uv', 'lock'], check=True)  # noqa: S607


def parse_scenario_version():
    """Parse the current scenario version from pyproject.toml."""
    file_path = VERSION_FILES['testing']
    content = file_path.read_text()
    match = re.search(rf'version = "{VERSION_REGEX}"', content)
    if not match:
        raise ValueError(f'Could not find version string in {file_path}')
    version_str = match.group(1)
    base_version, dev_suffix = parse_version(version_str)
    return base_version, dev_suffix


def get_new_scenario_version(ops_version: str) -> str:
    """Get a new version for scenario based on ops verwsion.

    We want the scenario version to always be exactly ops major version+5,
    like ops 3.1.2 -> scenario 8.1.2.
    """
    major, minor, patch, dev0 = ops_version.split('.')
    return f'{int(major) + 5}.{minor}.{patch}.{dev0}'


def update_versions_for_release(tag: str):
    """Update version files to the specified release version."""
    scenario_version = get_new_scenario_version(tag)
    update_ops_version(tag, scenario_version)
    update_testing_version(tag, scenario_version)
    update_tracing_version(tag)
    update_uv_lock()


def get_new_version_post_release(repo: github.Repository.Repository, branch_name: str) -> str:
    """Get the new version after the release.

    The value is generated by bumping the minor version of the latest release's tag
    and adding the '.dev0' suffix.
    """
    latest_version = get_latest_release_tag(repo, branch_name)

    if latest_version is None:
        logger.error('No version tags found in branch "{branch_name}".')
        exit(1)

    logger.info(f'Latest version in branch "{branch_name}": {latest_version}')

    # Check if the latest version is in SEMVER, in case it has a suffix like 3.0.0.post1.
    if not re.match(r'^\d+\.\d+\.\d+$', latest_version):
        logger.error(
            f'Latest version "{latest_version}" must be in format '
            f'X.Y.Z. Please input the new version manually (remember to add the .dev0 suffix).'
        )
        exit(1)

    new_version = bump_minor_version(latest_version) + '.dev0'
    logger.info(f'Suggested new version: {new_version}')
    return new_version


def update_versions_for_post_release(repo: github.Repository.Repository, branch_name: str):
    """Update version files to the post-release version with '.dev0' suffix."""
    ops_version = get_new_version_post_release(repo, branch_name)
    scenario_version = get_new_scenario_version(ops_version)
    update_ops_version(ops_version, scenario_version)
    update_testing_version(ops_version, scenario_version)
    update_tracing_version(ops_version)
    update_uv_lock()


def check_update_charm_pins_prs(repo: github.Repository.Repository):
    """Check for open PRs that update charm pins."""
    prs = repo.get_pulls(state='open')
    open_prs = [pr for pr in prs if pr.title == 'chore: update charm pins']
    if open_prs:
        logger.info('Please merge "update charm pins" PRs first:')
        pr = open_prs[0]
        pr_url = f'#{pr.number} - {pr.html_url}'
        logger.info(f'  {pr_url}')
        if len(open_prs) > 1:
            logger.info(
                f'Note that there are {len(open_prs) - 1} more open update charm pins PRs.'
            )
            exit(1)


def draft_release(
    owner: str, repo_name: str, base_branch: str, canonical_remote: str, fork_remote: str
):
    """Create a draft release, update changelog, and create a PR for the release."""
    subprocess.run(['/usr/bin/git', 'checkout', 'main'], check=True)
    subprocess.run(['/usr/bin/git', 'pull', canonical_remote, 'main'], check=True)

    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    check_update_charm_pins_prs(repo)

    tag = get_new_tag_for_release(owner, repo, base_branch)
    release = create_draft_release(repo, tag, base_branch)
    if not release:
        logger.error('Failed to create draft release.')
        exit(1)
    logger.info(f'Draft release created: {release.html_url}.')

    categories, full_changelog = parse_release_notes(release.body)
    notes = format_release_notes(categories, full_changelog)
    print_release_notes(notes)

    title, summary = input_title_and_summary(release)
    if not title:
        title = tag
    notes = f'{summary}\n{notes}'

    update_draft_release(release, title, notes)

    changes = format_changes(categories, tag)
    update_changes_file(changes, 'CHANGES.md')

    update_versions_for_release(tag)

    new_branch = f'release-prep-{tag}'
    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    changed_files = ['CHANGES.md', *[str(path) for path in VERSION_FILES.values()]]
    subprocess.run(['/usr/bin/git', 'add', *changed_files], check=True)
    subprocess.run(['/usr/bin/git', 'commit', '-m', f'chore: prepare release {tag}'], check=True)
    subprocess.run(['/usr/bin/git', 'push', fork_remote, new_branch], check=True)
    pr = repo.create_pull(
        title=f'chore: update changelog and versions for {tag} release',
        body=f'This PR prepares the release of version {tag}.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=base_branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


def post_release(
    owner: str, repo_name: str, base_branch: str, canonical_remote: str, fork_remote: str
):
    """Post-release actions: update version files and create a PR."""
    new_branch = 'post-release'
    local_branch = subprocess.run(
        ['/usr/bin/git', 'branch', '--list', new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    remote_branch = subprocess.run(
        ['/usr/bin/git', 'ls-remote', '--heads', fork_remote, new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    exist = local_branch or remote_branch
    if exist:
        logger.error(
            f'Branch "{new_branch}" already exists in the current repository. '
            'Please double check and delete it first before post release'
        )
        exit(1)

    subprocess.run(['/usr/bin/git', 'fetch', canonical_remote], check=True)
    subprocess.run(['/usr/bin/git', 'checkout', base_branch], check=True)
    subprocess.run(['/usr/bin/git', 'merge', f'{canonical_remote}/{base_branch}'], check=True)

    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    update_versions_for_post_release(repo, base_branch)

    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    files = [str(path) for path in VERSION_FILES.values()]
    subprocess.run(['/usr/bin/git', 'add', *files], check=True)
    subprocess.run(
        ['/usr/bin/git', 'commit', '-m', 'chore: update versions after release'], check=True
    )
    subprocess.run(['/usr/bin/git', 'push', fork_remote, new_branch], check=True)
    pr = repo.create_pull(
        title='chore: adjust versions after release',
        body='This PR updates the version files after the release.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=base_branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--repo',
        '-r',
        help='Repository name (e.g. "operator")',
        default='operator',
    )
    parser.add_argument(
        '--owner',
        '-o',
        help='Owner name (e.g. "canonical")',
        default='canonical',
    )
    parser.add_argument(
        '--canonical-remote',
        '-c',
        help='Remote name of canonical/operator (e.g. "upstream")',
        default='upstream',
    )
    parser.add_argument(
        '--fork-remote',
        '-f',
        help='Remote name of the forked operator repo (e.g. "origin")',
        default='origin',
    )
    parser.add_argument('--branch', '-b', help='Branch to create the release from', default='main')
    parser.add_argument(
        '--post-release',
        action='store_true',
        help='After release, bump version and add .dev0 suffix',
    )
    args = parser.parse_args()

    if args.post_release:
        post_release(
            owner=args.owner,
            repo_name=args.repo,
            base_branch=args.branch,
            canonical_remote=args.canonical_remote,
            fork_remote=args.fork_remote,
        )
        logger.info(
            'Post-release actions completed. Please check and merge the created PR '
            'for version updates.'
        )
        exit(0)

    draft_release(
        owner=args.owner,
        repo_name=args.repo,
        base_branch=args.branch,
        canonical_remote=args.canonical_remote,
        fork_remote=args.fork_remote,
    )
    logger.info(
        'Draft release created. Please merge the version bump PR, review and publish the draft'
        'release, then run this script with --post-release to perform post-release actions.'
    )
