# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Release automation script."""

from __future__ import annotations

import argparse
import logging
import os
import re
import subprocess
import time
import webbrowser
from datetime import datetime
from pathlib import Path

import github
import github.GitRelease
import github.Repository


class SymbolFormatter(logging.Formatter):
    """Custom logging formatter to use symbols for log levels."""

    from typing import ClassVar

    levels: ClassVar[dict[str, str]] = {
        'DEBUG': '🐛',
        'INFO': 'ℹ️',  # noqa: RUF001
        'WARNING': '⚠️',
        'ERROR': '❌',
        'CRITICAL': '🔥',
    }

    def format(self, record: logging.LogRecord) -> str:
        """Format the log record with symbols for level."""
        level = self.levels.get(record.levelname, '#')
        message = record.getMessage()
        return f'{level} {message}'


logger = logging.getLogger('release')
logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(SymbolFormatter())
logger.addHandler(handler)


if 'GITHUB_TOKEN' not in os.environ:
    logger.critical('Environment variable GITHUB_TOKEN not set.')
    exit(1)

auth = github.Auth.Token(os.environ['GITHUB_TOKEN'])
gh_client = github.Github(auth=auth)


VERSION_REGEX = r'(\d+\.\d+\.\d+(?:\.dev\d+)?)'
VERSION_FILES = {
    'ops/src': 'ops/version.py',
    'ops/pyproject': 'pyproject.toml',
    'testing': 'testing/pyproject.toml',
    'tracing': 'tracing/pyproject.toml',
    'uvlock': 'uv.lock',
}


def get_latest_release_tag(repo: github.Repository.Repository, branch_name: str) -> str | None:
    """Get the latest release tag from the repository."""
    releases = repo.get_releases()

    for release in releases:
        if release.draft:
            continue

        if 'maintenance' in branch_name:
            version = branch_name.split('-')[0]
            if version not in release.tag_name:
                continue

        return release.tag_name

    return None


def bump_minor_version(version: str) -> str:
    """Bump minor version."""
    major, minor, patch = map(int, version.split('.'))
    return f'{major}.{minor + 1}.{patch}'


def get_new_tag_for_release(
    owner: str, repo: github.Repository.Repository, branch_name: str
) -> str:
    """Get a new tag for release.

    Default value is generated by increasing the minor version of the latest release's tag.

    Can be overridden with a user-provided version.
    """
    latest_tag = get_latest_release_tag(repo, branch_name)

    suggested_tag = ''
    if not latest_tag:
        logger.info(f'No version tag found in branch "{branch_name}"')
    else:
        logger.info(f'Latest tag in branch "{branch_name}": {latest_tag}')
        if not re.match(r'^\d+\.\d+\.\d+$', latest_tag):
            logger.info('Latest tag is not in format X.Y.Z.')
        else:
            suggested_tag = bump_minor_version(latest_tag)
            logger.info(f'Suggested new version: {suggested_tag}')

    while True:
        user_input = input(
            f'Input tag to release (press enter to use the suggested tag '
            f"{suggested_tag or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Release canceled.')
            exit(0)

        new_tag = user_input if user_input else suggested_tag

        if not new_tag:
            logger.error('Error: No tag specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', new_tag):
            logger.error('Error: Tag must be in format X.Y.Z')
            continue

        release_page = f'https://github.com/{owner}/{repo.name}/releases'
        logger.warning(f'Check out the releases page: {release_page} before confirming!')

        confirm = (
            input(f"Confirm creating tag '{new_tag}' on branch '{branch_name}'? [y/N]: ")
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return new_tag


def create_draft_release(
    repo: github.Repository.Repository, tag: str, branch: str
) -> github.GitRelease.GitRelease | None:
    """Create a draft release with auto-generated notes."""
    max_retries = 3
    for attempt in range(1, max_retries + 1):
        try:
            release = repo.create_git_release(
                tag=tag,
                name=tag,
                draft=True,
                generate_release_notes=True,
                target_commitish=branch,
            )
            return release
        except Exception as e:
            logger.error(f'Attempt {attempt} failed to create release: {e}')
        if attempt == max_retries:
            raise
        time.sleep(1)

    return None


def parse_release_notes(release_notes: str) -> tuple[dict[str, list[tuple[str, str]]], str | None]:
    """Parse auto-generated release notes into categories.

    The "New Contributors" section is removed.
    The PRs are categorized into 'feat', 'fix', 'docs', 'test', and 'ci'.
    The full changelog line is returned separately.

    Returns:
        A tuple containing:
        - A dict with conventional commit types as keys and lists of tuples (description, PR link)
          as values.
        - The full changelog line if present, or None if not found.
    """
    release_notes = re.sub(
        r'(## New Contributors.*?)(\n|$)', r'\2', release_notes, flags=re.DOTALL
    )
    categories: dict[str, list[tuple[str, str]]] = {
        'feat': [],
        'fix': [],
        'docs': [],
        'test': [],
        'ci': [],
    }
    full_changelog_line = None

    for line in release_notes.splitlines():
        line = line.strip()
        if line.startswith('* '):
            match = re.match(r'\* (\w+): (.*) by @\w+ in (.*)', line)
            if match:
                category = match.group(1)
                description = match.group(2).strip()
                description = description[0].upper() + description[1:]
                pr_link = match.group(3).strip()
                if category in categories:
                    categories[category].append((description, pr_link))
        elif line.startswith('**Full Changelog**'):
            full_changelog_line = line

    return categories, full_changelog_line


def format_release_notes(
    categories: dict[str, list[tuple[str, str]]], full_changelog: str | None
) -> str:
    """Format for release notes.

    Results in a Markdown formatted string with sections for each commit type.
    If `full_changelog` is provided, it is appended at the end.
    """
    res = "## What's Changed\n\n"

    for commit_type, items in categories.items():
        if items:
            res += f'### {commit_type_to_category(commit_type)}\n'

            for description, pr_link in items:
                res += f'* {description} in {pr_link}\n'

            res += '\n'

    if full_changelog:
        res += full_changelog

    return res


def print_release_notes(notes: str):
    """Print formatted release notes.

    So that user can review them and use them to write the title and summary.
    """
    print('=' * 80)
    print('Formatted release notes:')
    print('=' * 80)
    print(notes)
    print('=' * 80)


def input_title_and_summary(release: github.GitRelease.GitRelease) -> tuple[str, str]:
    """Ask user to input the release title and summary."""
    logger.info(f'The automatically generated title is: {release.title}')
    title = input('Enter release title, press Enter to keep the auto-generated title:\n> ').strip()
    if not title:
        title = release.title

    print("\nEnter release summary (multi-line supported; type '.' on a new line to finish):")

    lines: list[str] = []
    while True:
        line = input()
        if line.strip() == '.':
            break
        lines.append(line)

    summary = '\n'.join(lines).strip()
    summary = summary.lstrip('\n')
    summary = summary.rstrip('\n') + '\n'

    return title, summary


def update_draft_release(release: github.GitRelease.GitRelease, title: str, notes: str):
    """Update the release with the provided title and notes."""
    max_retries = 3
    for attempt in range(1, max_retries + 1):
        try:
            release.update_release(name=title, message=notes, draft=True)
            break
        except Exception as e:
            logger.error(f'Attempt {attempt} failed to update release: {e}')
        if attempt == max_retries:
            raise
        time.sleep(1)
    logger.info('Release title and notes updated.')


def format_changes(categories: dict[str, list[tuple[str, str]]], tag: str) -> str:
    """Format for CHANGES.md.

    The header is formatted as a top-level heading with the tag and date.
    The content is a Markdown formatted string with sections for each commit type.
    Each item is formatted as a bullet point with the description and PR number in parentheses.
    """
    today = datetime.now().strftime('%d %B %Y')
    res = f'# {tag} - {today}\n\n'

    for commit_type, items in categories.items():
        if items:
            res += f'## {commit_type_to_category(commit_type)}\n\n'

            for description, pr_link in items:
                pr_num = '?'
                match = re.match(r'https?://[^ ]+/pull/(\d+)', pr_link)
                if match:
                    pr_num = match.group(1)
                res += f'* {description} (#{pr_num})\n'

            res += '\n'

    return res


def update_changes_file(changes: str, file: str):
    """Update the changes file with new release notes."""
    existing_content = ''
    if os.path.exists(file):
        with open(file) as f:
            existing_content = f.read()

    new_content = changes + existing_content

    with open(file, 'w') as f:
        f.write(new_content)

    logger.info(f'Updated {file} with new release notes.')


def commit_type_to_category(commit_type: str) -> str:
    """Map commit type to a human-readable category.

    If the commit type is not recognized, it returns the capitalized commit type.
    """
    mapping = {
        'feat': 'Features',
        'fix': 'Fixes',
        'docs': 'Documentation',
        'test': 'Tests',
        'ci': 'CI',
    }
    return mapping.get(commit_type, commit_type.capitalize())


def parse_version(version: str) -> tuple[str, str]:
    """Parse version string into base version and dev suffix.

    The version should be in the format X.Y.Z or X.Y.Z.devN.
    The ".devN" part is the dev suffix.
    If there is no dev suffix, it returns an empty string for the dev suffix.

    Raises:
        ValueError if the version format is invalid.
    """
    match = re.fullmatch(r'(\d+\.\d+\.\d+)(\.dev\d+)?', version)
    if not match:
        raise ValueError(f'Invalid version format: {version}')
    base_version = match.group(1)
    dev_suffix = match.group(2) or ''
    return base_version, dev_suffix


def update_ops_version(ops_version: str, testing_version: str):
    """Update the ops version in version.py and pyproject.toml."""
    # version.py
    ops_src_file = VERSION_FILES['ops/src']
    ops_src_file_path = Path(ops_src_file)
    content = ops_src_file_path.read_text()
    updated = re.sub(
        r'^version: str = \'' + VERSION_REGEX + r'\'$',
        f"version: str = '{ops_version}'",
        content,
        flags=re.MULTILINE,
    )
    ops_src_file_path.write_text(updated)
    logger.info(f'Updated {ops_src_file} to version {ops_version}')

    # pyproject.toml
    # Update both ops-scenario and ops-tracing versions.
    ops_pyproject_file = VERSION_FILES['ops/pyproject']
    ops_pyproject_file_path = Path(ops_pyproject_file)
    content = ops_pyproject_file_path.read_text()
    updated = re.sub(
        r'ops-scenario==' + VERSION_REGEX,
        f'ops-scenario=={testing_version}',
        content,
    )
    updated = re.sub(
        r'ops-tracing==' + VERSION_REGEX,
        f'ops-tracing=={ops_version}',
        updated,
    )
    # Fail if nothing is changed.
    if content == updated:
        logger.error(f'No changes made to {ops_pyproject_file}. Check the versions.')
        exit(1)
    ops_pyproject_file_path.write_text(updated)
    logger.info(f'Updated {ops_pyproject_file} to ops {ops_version} testing {testing_version}')


def update_testing_version(ops_version: str, testing_version: str):
    """Update the testing pyproject version."""
    file = VERSION_FILES['testing']
    file_path = Path(file)
    content = file_path.read_text()
    updated = re.sub(
        r'version = "' + VERSION_REGEX + '"',
        f'version = "{testing_version}"',
        content,
    )
    updated = re.sub(
        r'ops==' + VERSION_REGEX,
        f'ops=={ops_version}',
        updated,
    )
    # Fail if nothing is changed.
    if content == updated:
        logger.error(f'No changes made to {file}. Check the versions.')
        exit(1)
    file_path.write_text(updated)
    logger.info(f'Updated {file} to ops {ops_version} testing {testing_version}')


def update_tracing_version(ops_version: str):
    """Update the tracing pyproject version."""
    file = VERSION_FILES['tracing']
    file_path = Path(file)
    content = file_path.read_text()
    updated = re.sub(
        r'version = "' + VERSION_REGEX + '"',
        f'version = "{ops_version}"',
        content,
    )
    updated = re.sub(
        r'ops==' + VERSION_REGEX,
        f'ops=={ops_version}',
        updated,
    )
    # Fail if nothing is changed.
    if content == updated:
        logger.error(f'No changes made to {file}. Check the versions.')
        exit(1)
    file_path.write_text(updated)
    logger.info(f'Updated {file} to version {ops_version}')


def update_uv_lock():
    """Update the uv.lock file with the new versions."""
    subprocess.run(['uv', 'lock'], check=True)  # noqa: S607


def parse_scenario_version():
    """Parse the current scenario version from pyproject.toml."""
    file = VERSION_FILES['testing']
    file_path = Path(file)
    content = file_path.read_text()
    match = re.search(r'version = "' + VERSION_REGEX + '"', content)
    if not match:
        raise ValueError(f'Could not find version string in {file}')
    version_str = match.group(1)
    base_version, dev_suffix = parse_version(version_str)
    return base_version, dev_suffix


def get_new_scenario_version_for_release() -> str:
    """Get a new version for scenario.

    Default value is generated by removing the ".dev0" suffix from the current scenario version.

    Can be overridden with a user-provided version.
    """
    suggested_version, _ = parse_scenario_version()
    logger.info(f'Suggested new scenario version: {suggested_version}')

    while True:
        user_input = input(
            f'Input new scenario version (press enter to use the suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Scenario version creation canceled.')
            exit(0)

        suggested_version = user_input if user_input else suggested_version

        if not suggested_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', suggested_version):
            logger.error('Error: Version must be in format X.Y.Z')
            continue

        confirm = (
            input(f"Confirm using scenario version '{suggested_version}'? [y/N]: ").strip().lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return suggested_version


def update_versions_for_release(tag: str):
    """Update version files to the specified release version."""
    scenario_version = get_new_scenario_version_for_release()
    update_ops_version(tag, scenario_version)
    update_testing_version(tag, scenario_version)
    update_tracing_version(tag)
    update_uv_lock()


def get_new_version_post_release(repo: github.Repository.Repository, branch_name: str) -> str:
    """Get the new version after the release.

    Default value is generated by bumping the minor version of the latest release's tag
    and adding the '.dev0' suffix.

    Can be overridden with a user-provided version.
    """
    latest_version = get_latest_release_tag(repo, branch_name)

    if latest_version is None:
        logger.info('No version tags found in branch "{branch_name}".')
        suggested_version = ''
    else:
        logger.info(f'Latest version in branch "{branch_name}": {latest_version}')

        # Check if the latest version is in SEMVER, in case it has a suffix.
        if not re.match(r'^\d+\.\d+\.\d+$', latest_version):
            logger.warning(
                f'Latest version "{latest_version}" must be in format '
                f'X.Y.Z. Please input the new version manually (remember to add the .dev0 suffix).'
            )
            suggested_version = ''
        else:
            suggested_version = bump_minor_version(latest_version) + '.dev0'
            logger.info(f'Suggested new version: {suggested_version}')

    while True:
        user_input = input(
            f'Input post release version (press enter to use suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Post release canceled.')
            exit(0)

        new_version = user_input if user_input else suggested_version

        if not new_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        confirm = (
            input(f"Confirm using version '{new_version}' for post release'? [y/N]: ")
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return new_version


def get_new_scenario_version_post_release() -> str:
    """Get a new post release version for scenario.

    Default value is generated by bumping the current minor version and add the .dev0 suffix.

    Can be overridden with a user-provided version.
    """
    suggested_version, _ = parse_scenario_version()
    suggested_version += '.dev0'
    logger.info(f'Suggested new scenario version: {suggested_version}')

    while True:
        user_input = input(
            f'Input post release scenario version (press enter to use suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Post release canceled.')
            exit(0)

        suggested_version = user_input if user_input else suggested_version

        if not suggested_version:
            logger.error('Error: No version specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+\.dev\d+$', suggested_version):
            logger.error('Error: Version must be in format X.Y.Z.devN')
            continue

        confirm = (
            input(
                f"Confirm using scenario version '{suggested_version}' for post release? [y/N]: "
            )
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return suggested_version


def update_versions_for_post_release(repo: github.Repository.Repository, branch_name: str):
    """Update version files to the post-release version with '.dev0' suffix."""
    ops_version = get_new_version_post_release(repo, branch_name)
    scenario_version = get_new_scenario_version_post_release()
    update_ops_version(ops_version, scenario_version)
    update_testing_version(ops_version, scenario_version)
    update_tracing_version(ops_version)
    update_uv_lock()


def countdown(msg: str, t: int):
    """Countdown timer to show before exiting."""
    while t:
        timer = f'00:{t:02d}'
        print(f'{msg}: {timer}', end='\r')
        time.sleep(1)
        t -= 1


def check_update_charm_pins_prs(repo: github.Repository.Repository):
    """Check for open PRs that update charm pins."""
    prs = repo.get_pulls(state='open')
    open_prs = [pr for pr in prs if pr.title == 'chore: update charm pins']
    if open_prs:
        logger.info('Please merge "update charm pins" PRs first:')
        pr = open_prs[0]
        pr_url = f'#{pr.number} - {pr.html_url}'
        logger.info(f'  {pr_url}')
        if len(open_prs) > 1:
            logger.info(
                f'Note that there are {len(open_prs) - 1} more open update charm pins PRs.'
            )
        countdown('Exiting and opening the charm pins PR in: ', 3)
        webbrowser.open(pr.html_url)
        exit(1)


def draft_release(owner: str, repo_name: str, branch: str):
    """Create a draft release, update changelog, and create a PR for the release."""
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    check_update_charm_pins_prs(repo)

    tag = get_new_tag_for_release(owner, repo, branch)
    release = create_draft_release(repo, tag, branch)
    if not release:
        logger.error('Failed to create draft release.')
        exit(1)
    logger.info(f'Draft release created: {release.html_url}.')

    categories, full_changelog = parse_release_notes(release.body)
    notes = format_release_notes(categories, full_changelog)
    print_release_notes(notes)

    title, summary = input_title_and_summary(release)
    if not title:
        title = tag
    notes = f'{summary}\n{notes}'

    update_draft_release(release, title, notes)

    changes = format_changes(categories, tag)
    update_changes_file(changes, 'CHANGES.md')

    update_versions_for_release(tag)

    new_branch = f'release-prep-{tag}'
    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    changed_files = ['CHANGES.md', *VERSION_FILES.values()]
    for file in changed_files:
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(['/usr/bin/git', 'commit', '-m', f'chore: prepare release {tag}'], check=True)
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title=f'chore: update changelog and versions for {tag} release',
        body=f'This PR prepares the release of version {tag}.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=branch,
    )
    logger.info(f'Created PR: {pr.html_url}')
    countdown('Opening the PR in: ', 3)
    webbrowser.open(pr.html_url)


def publish_draft_release(owner: str, repo_name: str):
    """Publish the draft release."""
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    releases = repo.get_releases()
    draft = None
    for release in releases:
        if release.draft:
            draft = release
            break

    if not draft:
        logger.error('No draft release found. Please create a draft release first.')
        return

    while True:
        confirm = (
            input(f"Confirm publishing draft release '{draft.html_url}'? [y/N]: ").strip().lower()
        )

        if confirm.lower() == 'n':
            logger.warning('Release publish canceled.')
            exit(0)

        if confirm == 'y':
            break

    logger.info(f'Publishing draft release: {draft.title} {draft.html_url}')
    draft.update_release(name=draft.title, message=draft.body, draft=False)


def post_release(owner: str, repo_name: str, branch: str):
    """Post-release actions: update version files and create a PR."""
    new_branch = 'post-release'
    local_branch = subprocess.run(
        ['/usr/bin/git', 'branch', '--list', new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    remote_branch = subprocess.run(
        ['/usr/bin/git', 'ls-remote', '--heads', 'origin', new_branch],
        capture_output=True,
        text=True,
        check=True,
    ).stdout.strip()
    exist = local_branch or remote_branch
    if exist:
        logger.error(
            f'Branch "{new_branch}" already exists in the current repository. '
            'Please double check and delete it first before post release'
        )
        exit(1)

    subprocess.run(['/usr/bin/git', 'fetch', 'upstream'], check=True)
    subprocess.run(['/usr/bin/git', 'checkout', branch], check=True)
    subprocess.run(['/usr/bin/git', 'merge', f'upstream/{branch}'], check=True)

    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    update_versions_for_post_release(repo, branch)

    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    for file in VERSION_FILES.values():
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(
        ['/usr/bin/git', 'commit', '-m', 'chore: update versions after release'], check=True
    )
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title='Post Release',
        body='This PR updates the version files after the release.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=branch,
    )
    logger.info(f'Created PR: {pr.html_url}')
    countdown('Opening the PR in: ', 3)
    webbrowser.open(pr.html_url)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--repo',
        '-r',
        help='Repository name (e.g. "operator")',
        default='operator',
    )
    parser.add_argument(
        '--owner',
        '-o',
        help='Owner name (e.g. "Canonical")',
        default='Canonical',
    )
    parser.add_argument('--branch', '-b', help='Branch to create the release from', default='main')
    parser.add_argument(
        '--publish',
        action='store_true',
        help='After drafting a release and merging the version bump PR, publish the release',
    )
    parser.add_argument(
        '--post-release',
        action='store_true',
        help='After release, bump version and add .dev0 suffix',
    )
    args = parser.parse_args()

    if args.publish:
        publish_draft_release(owner=args.owner, repo_name=args.repo)
        logger.info(
            'Draft release published. Please run this script with --post-release '
            'to update the version files.'
        )
        exit(0)

    if args.post_release:
        post_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
        logger.info(
            'Post-release actions completed. Please check and merge the created PR '
            'for version updates.'
        )
        exit(0)

    draft_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
    logger.info(
        'Draft release created. Please merge the version bump PR and then run this script '
        'with --publish to publish the release.'
    )
