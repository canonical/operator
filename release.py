# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Release automation script."""

from __future__ import annotations

import argparse
import logging
import os
import re
import subprocess
import time
import webbrowser
from datetime import datetime
from pathlib import Path
from typing import Any

import github
import github.GitRelease
import github.Repository

logger = logging.getLogger()
logger.setLevel(logging.INFO)


class MyHandler(logging.StreamHandler[Any]):
    """Custom logging handler to format messages based on their level."""

    def format(self, record: logging.LogRecord):
        """Format the log record based on its level."""
        if record.levelno == logging.INFO:
            self.setFormatter(logging.Formatter('ℹ️ INFO: %(message)s'))  # noqa: RUF001
        elif record.levelno == logging.WARNING:
            self.setFormatter(logging.Formatter('⚠️ WARNING: %(message)s'))
        elif record.levelno == logging.ERROR:
            self.setFormatter(logging.Formatter('❌ ERROR: %(message)s'))
        return super().format(record)


logger.addHandler(MyHandler())

if 'GITHUB_TOKEN' not in os.environ:
    logger.critical('Environment variable GITHUB_TOKEN not set.')
    exit(1)

VERSION_STR = r'(\d+\.\d+\.\d+(?:\.dev\d+)?)'
OPS_SRC_VERSION_STR = r'version: str = \'' + VERSION_STR + "'"
PYPROJECT_VERSION_STR = r'version = "' + VERSION_STR + '"'
PYPROJECT_OPS_VERSION_STR = r'ops==' + VERSION_STR
PYPROJECT_TESTING_VERSION_STR = r'ops-scenario==' + VERSION_STR
PYPROJECT_TRACING_VERSION_STR = r'ops-tracing==' + VERSION_STR
# match the following two lines in uv.lock:
# name = "ops-scenario"
# version = "7.23.0.dev0"
UVLOCK_TESTING_VERSION_STR = r'name = "ops-scenario"\nversion = "' + VERSION_STR + '"'
# match the following two lines in uv.lock:
# name = "ops-tracing"
# version = "2.23.0.dev0"
UVLOCK_TRACING_VERSION_STR = r'name = "ops-tracing"\nversion = "' + VERSION_STR + '"'
VERSION_FILES = {
    'ops/src': 'ops/version.py',
    'ops/pyproject': 'pyproject.toml',
    'testing': 'testing/pyproject.toml',
    'tracing': 'tracing/pyproject.toml',
    'uvlock': 'uv.lock',
}

auth = github.Auth.Token(os.environ['GITHUB_TOKEN'])
gh_client = github.Github(auth=auth)


def get_latest_version(repo: github.Repository.Repository, branch_name: str) -> str | None:
    """Get the latest version from releases."""
    releases = repo.get_releases()

    for release in releases:
        if 'maintenance' in branch_name:
            version = branch_name.split('-')[0]
            if version not in release.tag_name:
                continue

        return release.tag_name

    return None


def bump_minor_version(version: str) -> str:
    """Bump minor version."""
    major, minor, patch = map(int, version.split('.'))
    return f'{major}.{minor + 1}.{patch}'


def get_new_version(owner: str, repo: github.Repository.Repository, branch_name: str) -> str:
    """Get a new version for release.

    Default value is generated by increasing the patch version of the latest version.

    Can be overridden with a user-provided version.
    """
    latest_version = get_latest_version(repo, branch_name)

    if latest_version is None:
        logger.info('No version tags found in branch "{branch_name}".')
        suggested_version = ''
    else:
        suggested_version = bump_minor_version(latest_version)
        logger.info(f'Latest version in branch "{branch_name}": {latest_version}')
        logger.info(f'Suggested new version: {suggested_version}')

    while True:
        user_input = input(
            f'Input version to release (press enter to use suggested version '
            f"{suggested_version or 'required'}), or 'c' to cancel: "
        ).strip()

        if user_input.lower() == 'c':
            logger.warning('Release creation canceled.')
            return ''

        version_to_use = user_input if user_input else suggested_version

        if not version_to_use:
            logger.error('Error: No version specified and no suggestion available')
            continue

        if not re.match(r'^\d+\.\d+\.\d+$', version_to_use):
            logger.error('Error: Version must be in format X.Y.Z')
            continue

        release_page = f'https://github.com/{owner}/{repo.name}/releases'
        logger.warning(f'Check out the releases page: {release_page} before confirming!')

        confirm = (
            input(
                f"Confirm creating release '{version_to_use}' on branch '{branch_name}'? [y/N]: "
            )
            .strip()
            .lower()
        )

        if confirm == 'y':
            break

        logger.info("Let's try again...")

    return version_to_use


def create_draft_release(
    repo: github.Repository.Repository, tag: str, branch: str
) -> github.GitRelease.GitRelease | None:
    """Create a draft release with auto-generated notes."""
    try:
        release = repo.create_git_release(
            tag=tag,
            name=tag,
            draft=True,
            generate_release_notes=True,
            target_commitish=branch,
        )
        return release
    except Exception as e:
        logging.error(f'Error creating release: {e}')


def parse_release_notes(release_notes: str) -> tuple[dict[str, list[tuple[str, str]]], str | None]:
    """Parse auto-generated release notes into categories."""
    # Remove "New Contributors" section.
    release_notes = re.sub(
        r'(## New Contributors.*?)(\n|$)', r'\2', release_notes, flags=re.DOTALL
    )
    categories: dict[str, list[tuple[str, str]]] = {
        'feat': [],
        'fix': [],
        'docs': [],
        'test': [],
        'ci': [],
    }
    full_changelog_line = None

    for line in release_notes.splitlines():
        line = line.strip()
        if line.startswith('* '):
            match = re.match(r'\* (\w+): (.*) by @\w+ in (.*)', line)
            if match:
                category = match.group(1)
                description = match.group(2).strip()
                description = description[0].upper() + description[1:]
                pr_link = match.group(3).strip()
                if category in categories:
                    categories[category].append((description, pr_link))
        elif line.startswith('**Full Changelog**'):
            full_changelog_line = line

    return categories, full_changelog_line


def format_notes(categories: dict[str, list[tuple[str, str]]], full_changelog: str | None) -> str:
    """Format for release notes."""
    res = "## What's Changed\n\n"

    for commit_type, items in categories.items():
        if items:
            res += f'### {commit_type_to_category(commit_type)}\n'

            for description, pr_link in items:
                res += f'* {description} in {pr_link}\n'

            res += '\n'

    if full_changelog:
        res += full_changelog

    return res


def print_notes(notes: str):
    """Print formatted release notes."""
    print('=' * 80)
    print('Formatted release notes:')
    print('=' * 80)
    print(notes)
    print('=' * 80)


def get_title_and_summary(auto_generated_title: str) -> tuple[str, str]:
    """Get title and summary for the release."""
    print(f'The automatically generated title is: {auto_generated_title}')
    title = input('Enter release title, press Enter to keep the auto-generated title:\n> ').strip()
    if not title:
        title = auto_generated_title

    print("\nEnter release summary (multi-line supported, type '.' on a new line to finish):")

    lines: list[str] = []
    while True:
        line = input()
        if line.strip() == '.':
            break
        lines.append(line)

    summary = '\n'.join(lines).strip()
    summary = summary.lstrip('\n')
    summary = summary.rstrip('\n') + '\n'

    return title, summary


def update_draft_release(release: github.GitRelease.GitRelease, title: str, notes: str):
    """Update the release with the provided title and notes."""
    try:
        release.update_release(name=title, message=notes, draft=True)
        logger.info('Release title and notes updated.')
    except Exception as e:
        print(f'Error creating release: {e}')


def format_changes(categories: dict[str, list[tuple[str, str]]], tag: str) -> str:
    """Format for changelog."""
    today = datetime.now().strftime('%d %B %Y')
    res = f'# {tag} - {today}\n\n'

    for commit_type, items in categories.items():
        if items:
            res += f'## {commit_type_to_category(commit_type)}\n\n'

            for description, pr_link in items:
                pr_num = '?'
                match = re.match(r'https?://[^ ]+/pull/(\d+)', pr_link)
                if match:
                    pr_num = match.group(1)
                res += f'* {description} (#{pr_num})\n'

            res += '\n'

    return res


def update_changes_file(changes: str, changes_file: str):
    """Update the changes file with new release notes."""
    existing_content = ''
    if os.path.exists(changes_file):
        with open(changes_file) as f:
            existing_content = f.read()

    new_content = changes + existing_content

    with open(changes_file, 'w') as f:
        f.write(new_content)

    logger.info(f'Updated {changes_file} with new release notes.')


def commit_type_to_category(commit_type: str) -> str:
    """Map commit type to a human-readable category."""
    mapping = {
        'feat': 'Features',
        'fix': 'Fixes',
        'docs': 'Documentation',
        'test': 'Tests',
        'ci': 'CI',
    }
    return mapping.get(commit_type, commit_type.capitalize())


def parse_version(version: str) -> tuple[str, str]:
    """Parse version string into base version and dev suffix."""
    match = re.fullmatch(r'(\d+\.\d+\.\d+)(\.dev\d+)?', version)
    if not match:
        raise ValueError(f'Invalid version format: {version}')
    base_version = match.group(1)
    dev_suffix = match.group(2) or ''
    return base_version, dev_suffix


def get_testing_version_without_dev_suffix():
    """Parse the current version of the testing module without .dev0 suffix."""
    file = VERSION_FILES['testing']
    file_path = Path(file)
    content = file_path.read_text()
    match = re.search(PYPROJECT_VERSION_STR, content)
    if not match:
        raise ValueError(f'Could not find version string in {file}')
    version_str = match.group(1)
    current_version, _ = parse_version(version_str)
    return current_version


def update_ops_version(new_ops_version: str, new_testing_version: str):
    """Update the ops version in version.py and pyproject.toml."""
    # version.py
    ops_src_file = VERSION_FILES['ops/src']
    ops_src_file_path = Path(ops_src_file)
    content = ops_src_file_path.read_text()
    updated = re.sub(
        OPS_SRC_VERSION_STR,
        f"version: str = '{new_ops_version}'",
        content,
    )
    ops_src_file_path.write_text(updated)
    logger.info(f'Updated {ops_src_file} to release version: {new_ops_version}')

    # pyproject
    ops_pyproject_file = VERSION_FILES['ops/pyproject']
    ops_pyproject_file_path = Path(ops_pyproject_file)
    content = ops_pyproject_file_path.read_text()
    updated = re.sub(
        PYPROJECT_TESTING_VERSION_STR,
        f'ops-scenario=={new_testing_version}',
        content,
    )
    updated = re.sub(
        PYPROJECT_TRACING_VERSION_STR,
        f'ops-tracing=={new_ops_version}',
        updated,
    )
    ops_pyproject_file_path.write_text(updated)
    logger.info(
        f'Updated {ops_pyproject_file} to release version: ops {new_ops_version}'
        f' testing {new_testing_version}'
    )


def update_testing_pyproject_version(new_ops_version: str, new_testing_version: str):
    """Update the testing pyproject version."""
    file = VERSION_FILES['testing']
    file_path = Path(file)
    content = file_path.read_text()
    updated = re.sub(
        PYPROJECT_VERSION_STR,
        f'version = "{new_testing_version}"',
        content,
    )
    updated = re.sub(
        PYPROJECT_OPS_VERSION_STR,
        f'ops=={new_ops_version}',
        updated,
    )
    file_path.write_text(updated)
    logger.info(
        f'Updated {file} to release version: ops {new_ops_version} testing {new_testing_version}'
    )


def update_tracing_pyproject_version(new_ops_version: str):
    """Update the tracing pyproject version."""
    file = VERSION_FILES['tracing']
    file_path = Path(file)
    content = file_path.read_text()
    updated = re.sub(
        PYPROJECT_VERSION_STR,
        f'version = "{new_ops_version}"',
        content,
    )
    updated = re.sub(
        PYPROJECT_OPS_VERSION_STR,
        f'ops=={new_ops_version}',
        updated,
    )
    file_path.write_text(updated)
    logger.info(f'Updated {file} to release version: ops {new_ops_version}')


def update_uv_lock():
    """Update the uv.lock file with the new versions."""
    subprocess.run(['uv', 'lock'], check=True)  # noqa: S607


def update_versions_for_release(version: str):
    """Update version files to the specified release version."""
    new_ops_version = version
    # Remove dev suffix, keep base version, bump minor version.
    new_testing_version = get_testing_version_without_dev_suffix()
    update_ops_version(new_ops_version, new_testing_version)
    update_testing_pyproject_version(new_ops_version, new_testing_version)
    update_tracing_pyproject_version(new_ops_version)
    update_uv_lock()


def update_versions_for_post_release(repo: github.Repository.Repository, branch_name: str):
    """Update version files to the post-release version with '.dev0' suffix."""
    latest_ops_version = get_latest_version(repo, branch_name)
    if not latest_ops_version:
        logger.error(f'No latest version found in branch "{branch_name}".')
        raise ValueError('No latest version found.')
    new_ops_version = bump_minor_version(latest_ops_version) + '.dev0'
    new_testing_version = bump_minor_version(get_testing_version_without_dev_suffix()) + '.dev0'
    update_ops_version(new_ops_version, new_testing_version)
    update_testing_pyproject_version(new_ops_version, new_testing_version)
    update_tracing_pyproject_version(new_ops_version)
    update_uv_lock()


def countdown(msg: str, t: int):
    """Countdown timer to show before exiting."""
    while t:
        timer = f'00:{t:02d}'
        print(f'{msg}: {timer}', end='\r')
        time.sleep(1)
        t -= 1


def check_update_charm_pins_prs(repo: github.Repository.Repository):
    """Check for open PRs that update charm pins."""
    prs = repo.get_pulls(state='open')
    open_prs = [pr for pr in prs if pr.title == 'chore: update charm pins']
    if open_prs:
        logger.info('Please merge "update charm pins" PRs first:')
        pr = open_prs[0]
        pr_url = f'#{pr.number} - {pr.html_url}'
        logger.info(f'  {pr_url}')
        if len(open_prs) > 1:
            logger.info(
                f'Note that there are {len(open_prs) - 1} more open update charm pins PRs.'
            )
        countdown('Exiting and opening the charm pins PR in: ', 3)
        webbrowser.open(pr.html_url)
        exit(1)


def draft_release(owner: str, repo_name: str, branch: str):
    """Create a draft release, update changelog, and create a PR for the release."""
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    check_update_charm_pins_prs(repo)

    tag = get_new_version(owner, repo, branch)

    release = create_draft_release(repo, tag, branch)
    if not release:
        logger.error('Failed to create draft release.')
        exit(1)
    logger.info(f'Draft release created: {release.html_url}.')

    categories, full_changelog = parse_release_notes(release.body)
    notes = format_notes(categories, full_changelog)
    print_notes(notes)
    title, summary = get_title_and_summary(release.title)
    if not title:
        title = tag
    notes = f'{summary}\n{notes}'
    update_draft_release(release, title, notes)

    changes = format_changes(categories, tag)
    update_changes_file(changes, 'CHANGES.md')

    update_versions_for_release(tag)

    new_branch = f'release-prep-{tag}'
    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    changed_files = ['CHANGES.md', *VERSION_FILES.values()]
    for file in changed_files:
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(['/usr/bin/git', 'commit', '-m', f'chore: prepare release {tag}'], check=True)
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title=f'chore: update changelog and versions for {tag} release',
        body=f'This PR prepares the release of version {tag}.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


def publish_draft_release(owner: str, repo_name: str):
    """Publish the draft release."""
    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    releases = repo.get_releases()
    draft = None
    for release in releases:
        if release.draft:
            draft = release
            break

    if not draft:
        logger.error('No draft release found. Please create a draft release first.')
        return

    logger.info(f'Publishing draft release: {draft.title} {draft.html_url}')
    draft.update_release(name=draft.title, message=draft.body, draft=False)


def post_release(owner: str, repo_name: str, branch: str):
    """Post-release actions: update version files and create a PR."""
    subprocess.run(['/usr/bin/git', 'fetch', 'upstream'], check=True)
    subprocess.run(['/usr/bin/git', 'checkout', branch], check=True)
    subprocess.run(['/usr/bin/git', 'merge', f'upstream/{branch}'], check=True)

    org = gh_client.get_organization(owner)
    repo = org.get_repo(repo_name)

    update_versions_for_post_release(repo, branch)

    new_branch = 'post-release'
    subprocess.run(['/usr/bin/git', 'checkout', '-b', new_branch], check=True)
    for file in VERSION_FILES.values():
        subprocess.run(['/usr/bin/git', 'add', file], check=True)
    subprocess.run(
        ['/usr/bin/git', 'commit', '-m', 'chore: update versions after release'], check=True
    )
    subprocess.run(['/usr/bin/git', 'push', 'origin', new_branch], check=True)
    pr = repo.create_pull(
        title='Post Release',
        body='This PR updates the version files after the release.',
        head=f'{gh_client.get_user().login}:{new_branch}',  # "your_username:new_branch"
        base=branch,
    )
    logger.info(f'Created PR: {pr.html_url}')


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--repo',
        '-r',
        help='Repository name (e.g. "operator")',
        default='operator',
    )
    parser.add_argument(
        '--owner',
        '-o',
        help='Owner name (e.g. "Canonical")',
        default='Canonical',
    )
    parser.add_argument('--branch', '-b', help='Branch to create the release from', default='main')
    parser.add_argument(
        '--publish',
        action='store_true',
        help='After drafting a release and merging the version bump PR, publish the release',
    )
    parser.add_argument(
        '--post-release',
        action='store_true',
        help='After release, bump version and add .dev0 suffix',
    )
    args = parser.parse_args()

    if not args.publish and not args.post_release:
        draft_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
        logger.info(
            'Draft release created. Please merge the version bump PR and then run this script '
            'with --publish to publish the release.'
        )
        exit(0)

    if args.publish:
        publish_draft_release(owner=args.owner, repo_name=args.repo)
        logger.info(
            'Draft release published. Please run this script with --post-release '
            'to update the version files.'
        )
        exit(0)

    if args.post_release:
        post_release(owner=args.owner, repo_name=args.repo, branch=args.branch)
        logger.info(
            'Post-release actions completed. Please check and merge the created PR '
            'for version updates.'
        )
        exit(0)
