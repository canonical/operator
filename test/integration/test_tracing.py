# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Learn more about testing at
# https://ops.readthedocs.io/en/latest/explanation/testing.html

from __future__ import annotations

import json
import logging
import time
from typing import Any, Callable

import httpx
import jubilant


def test_direct_connection(build_charm: Callable[[], str], juju: jubilant.Juju):
    """The traced charm is connected to the trace data collector directly."""
    charm_path = build_charm()
    juju.deploy(charm_path)
    juju.integrate('test-tracing', 'tempo')
    status = juju.wait(jubilant.all_active)
    trace_api = status.apps['tempo-worker'].address

    spans = wait_spans(trace_api, ready=lambda spans: 'ops.main' in str(spans))
    assert 'ops.main' in [span['name'] for span in spans]

    event_names = [event['name'] for event in get_events(spans)]
    assert 'StartEvent' in event_names

    checkpoint = time.time()
    arg_value = 'the-one-action-arg-value'
    juju.run('test-tracing/0', 'one', params={'arg': arg_value})
    spans = wait_spans(trace_api, ready=lambda spans: 'one_action' in str(spans), since=checkpoint)

    # A span generated by ops
    assert 'one_action: TestTracingCharm' in [span['name'] for span in spans]
    # A span generated by the test charm
    assert 'custom trace on any action' in [span['name'] for span in spans]

    action_span = next(span for span in spans if span['name'] == 'custom trace on any action')
    assert arg_value in json.dumps(action_span)


def test_with_tls(build_charm: Callable[[], str], juju: jubilant.Juju):
    """The trace data collector has TLS enabled, connection is direct."""
    charm_path = build_charm()
    juju.deploy('self-signed-certificates')
    juju.integrate('tempo:certificates', 'self-signed-certificates')
    juju.wait(jubilant.all_active)

    juju.deploy(charm_path)
    juju.integrate('test-tracing', 'self-signed-certificates')
    juju.integrate('test-tracing', 'tempo')
    status = juju.wait(jubilant.all_active)
    trace_api = status.apps['tempo-worker'].address

    spans = wait_spans(trace_api, ready=lambda spans: 'ops.main' in str(spans), https=True)
    assert 'ops.main' in [span['name'] for span in spans]

    event_names = [event['name'] for event in get_events(spans)]
    assert 'StartEvent' in event_names


def wait_spans(
    address: str,
    ready: Callable[[list[dict[str, Any]]], bool],
    *,
    since: float = 0,
    https: bool = False,
    timeout: float = 60,
):
    deadline = time.time() + timeout
    spans = []
    while time.time() < deadline:
        spans = get_spans(address, since=since, https=https)
        if ready(spans):
            return spans
        logging.info('waiting for spans, will retry')
        time.sleep(1)
    logging.warning('giving up on waiting for spans')
    return spans


def get_spans(address: str, since: float = 0, https: bool = False):
    spans: list[dict[str, Any]] = []
    base_url = f'{"https" if https else "http"}://{address}:3200/api/'
    # Insecure HTTPS because we don't want to fetch CA list from self-signed-certificates
    with httpx.Client(base_url=base_url, timeout=5, verify=False) as client:  # noqa: S501
        response = client.get('search?tags=service.name=test-tracing')
        response.raise_for_status()
        for trace in response.json()['traces']:
            if float(trace['startTimeUnixNano']) / 1e9 < since:
                continue
            response = client.get(f'v2/traces/{trace["traceID"]}')
            response.raise_for_status()
            for resource in response.json()['trace']['resourceSpans']:
                for scope in resource['scopeSpans']:
                    spans.extend(scope['spans'])
    return spans


def get_events(spans: list[dict[str, Any]]):
    rv: list[dict[str, Any]] = []
    for span in spans:
        rv.extend(span.get('events', []))
    return rv
