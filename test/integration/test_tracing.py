# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Learn more about testing at: https://juju.is/docs/sdk/testing
from __future__ import annotations

import json
import logging
import time
from typing import Any, Callable

import httpx
import jubilant


def test_direct_connection(build_charm: Callable[[], str], juju: jubilant.Juju):
    charm_path = build_charm()
    juju.deploy(charm_path)
    juju.integrate('tracing-tester', 'tempo')
    status = juju.wait(jubilant.all_active)

    spans = wait_spans(status.apps['tempo-worker'].address, test=lambda s: 'ops.main' in str(s))
    assert 'ops.main' in [s['name'] for s in spans]

    event_names = [e['name'] for e in get_events(spans)]
    assert 'StartEvent' in event_names

    checkpoint = time.time()
    juju.run('tracing-tester/0', 'one', params={'arg': 'oneoneoneone'})
    spans = wait_spans(
        status.apps['tempo-worker'].address,
        since=checkpoint,
        test=lambda s: 'one_action' in str(s),
    )

    # A span generated by ops
    assert 'one_action: TracingTesterCharm' in [s['name'] for s in spans]
    # A span generated by the test charm
    assert 'on action' in [s['name'] for s in spans]

    action_span = next(s for s in spans if s['name'] == 'on action')
    assert 'oneoneoneone' in json.dumps(action_span)


def test_with_load_balancer(build_charm: Callable[[], str], juju: jubilant.Juju):
    charm_path = build_charm()
    print(charm_path)
    pass


def test_with_tls(build_charm: Callable[[], str], juju: jubilant.Juju):
    pass


def test_with_load_balancer_tls(build_charm: Callable[[], str], juju: jubilant.Juju):
    pass


def wait_spans(
    address: str,
    since: float = 0,
    *,
    test: Callable[[list[dict[str, Any]]], bool],
    timeout: float = 60,
):
    deadline = time.time() + timeout
    spans = []
    while time.time() < deadline:
        spans = get_spans(address, since)
        if test(spans):
            return spans
        logging.info('waiting for spans, will retry')
        time.sleep(1)
    logging.warning('giving up on waiting for spans')
    return spans


def get_spans(address: str, since: float = 0):
    spans: list[dict[str, Any]] = []
    with httpx.Client(base_url=f'http://{address}:3200/api/', timeout=5) as client:
        r = client.get('search?tags=service.name=tracing-tester')
        r.raise_for_status()
        for t in r.json()['traces']:
            if float(t['startTimeUnixNano']) / 1e9 < since:
                continue
            r = client.get('v2/traces/{t["traceID"]}')
            r.raise_for_status()
            for resource in r.json()["trace"]["resourceSpans"]:
                for scope in resource["scopeSpans"]:
                    spans.extend(scope["spans"])
    return spans


def get_events(spans: list[dict[str, Any]]):
    rv: list[dict[str, Any]] = []
    for span in spans:
        rv.extend(span.get('events', []))
    return rv
